<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>设置</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg-color: #f5f5f5;
      --text-color: #000;
      --border-color: #ccc;
      --tip-color: #666;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #222;
        --text-color: #eee;
        --border-color: #555;
        --tip-color: #aaa;
      }
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      padding: 20px;
      background-color: var(--bg-color);
      color: var(--text-color);
      user-select: none;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      font-size: 14px;
    }

    select {
      width: 100%;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background-color: var(--bg-color);
      color: var(--text-color);
      font-size: 14px;
    }

    .checkbox-container {
      display: grid;
      grid-template-columns: auto 1fr;
      column-gap: 8px;
    }

    .checkbox-container input {
      margin: 0;
      margin-top: 3px;
      /* 微调 checkbox 垂直位置 */
    }

    .checkbox-container label {
      margin: 0;
      font-weight: normal;
    }

    .checkbox-container .tip {
      grid-column: 2;
      margin: 5px 0 0 0;
      font-size: 12px;
      color: var(--tip-color);
    }
  </style>
</head>

<body>
  <div class="form-group">
    <label for="autoFlipStep">自动翻页时间间隔</label>
    <select id="autoFlipStep">
      <option value="15">15 秒</option>
      <option value="30">30 秒</option>
      <option value="45">45 秒</option>
      <option value="60">1 分钟</option>
    </select>
  </div>

  <div class="form-group checkbox-container">
    <input type="checkbox" id="keepAwake">
    <label for="keepAwake">后台不休，继续翻页</label>
    <div class="tip">选中后，即使窗口最小化或被遮挡，也会保持自动翻页。</div>
  </div>

  <div class="form-group checkbox-container">
    <input type="checkbox" id="rememberLastPage">
    <label for="rememberLastPage">阅读不停，自动记录</label>
    <div class="tip">选中后，会记录当前阅读进度，直接退出重进时畅读。</div>
  </div>

  <script>
    (function() {
      const tauri = window.__TAURI__;
      if (!tauri) {
        console.error("Tauri API not found.");
        return;
      }
      const invoke = tauri.core.invoke;
      const emit = tauri.event ? tauri.event.emit : (name) => console.warn("Emit not available:", name);

      const autoFlipStepSelect = document.getElementById('autoFlipStep');
      const keepAwakeCheckbox = document.getElementById('keepAwake');
      const rememberLastPageCheckbox = document.getElementById('rememberLastPage');

      // 1. Initial Load
      invoke('get_settings').then((settings) => {
        settings = settings || {};
        
        // Auto Flip Interval
        if (settings.autoFlip && settings.autoFlip.interval) {
          autoFlipStepSelect.value = settings.autoFlip.interval.toString();
        } else {
           autoFlipStepSelect.value = "30";
        }

        // Keep Awake
        if (settings.autoFlip && settings.autoFlip.keepAwake !== undefined) {
          keepAwakeCheckbox.checked = settings.autoFlip.keepAwake;
        } else {
           keepAwakeCheckbox.checked = true;
        }

        // Remember Last Page
        if (settings.rememberLastPage !== undefined) {
          rememberLastPageCheckbox.checked = settings.rememberLastPage;
        } else {
           rememberLastPageCheckbox.checked = true;
        }
      }).catch(e => console.error("Failed to load settings:", e));

      // 2. Change Handlers (Fetch fresh settings before saving to avoid overwriting other fields like 'active')
      
      autoFlipStepSelect.addEventListener('change', () => {
        const val = parseInt(autoFlipStepSelect.value, 10);
        invoke('get_settings').then((current) => {
           current = current || {};
           const existingAutoFlip = current.autoFlip || { active: false, interval: 30, keepAwake: true };
           
           const newAutoFlip = { ...existingAutoFlip, interval: val };
           
           invoke('save_settings', { settings: { autoFlip: newAutoFlip } }).then(() => {
             // Notify other windows (like main menu manager)
             emit('settings-updated');
           });
        });
      });

      keepAwakeCheckbox.addEventListener('change', () => {
        const val = keepAwakeCheckbox.checked;
        invoke('get_settings').then((current) => {
           current = current || {};
           const existingAutoFlip = current.autoFlip || { active: false, interval: 30, keepAwake: true };
           
           const newAutoFlip = { ...existingAutoFlip, keepAwake: val };
           
           invoke('save_settings', { settings: { autoFlip: newAutoFlip } }).then(() => {
             emit('settings-updated');
           });
        });
      });

      rememberLastPageCheckbox.addEventListener('change', () => {
        const val = rememberLastPageCheckbox.checked;
        invoke('get_settings').then((current) => {
           // rememberLastPage is top-level, so we can just send partial update?
           // No, save_settings does shallow merge. If we send { rememberLastPage: val }, it works fine.
           // But to be consistent and safe, we can just send the partial object.
           // Wait, if I send { rememberLastPage: val }, it merges into root. Correct.
           
           invoke('save_settings', { settings: { rememberLastPage: val } }).then(() => {
             emit('settings-updated');
           });
        });
      });

    })();
  </script>
</body>
</html>